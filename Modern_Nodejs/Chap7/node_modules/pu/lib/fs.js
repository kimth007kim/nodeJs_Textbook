"use strict";

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const write = exports.write = function(fd, data, _callback) {
	var f = path.parse(path.resolve(fd));
	if (typeof(_callback) == "function") {
		mkdir(f.dir, function() {
			fs.writeFile(fd, data, _callback);
		});
	} else {
		mkdir(f.dir);
		fs.writeFileSync(fd, data);
	}
};

const read = exports.read = function(fd, _callback) {
	return (_callback ? fs.readFile(fd, _callback) : fs.readFileSync(fd));
};

const byline = exports.byline = function(fd, handler, _end) {
	var rl = readline.createInterface({
		input: fs.createReadStream(fd)
	});
	rl.on("line", handler);
	if (typeof(_end) == "function")
		rl.on("close", _end);
};

const mv = exports.mv = function(source, target, _callback) {
	return (_callback ? fs.rename(source, target, _callback) : fs.renameSync(source, target));
};

const rm = exports.rm = function(fd, _callback) {
	var timeout = 0;
	var rimraf = function(p, cb) {
		_rimraf(p, function CB(er) {
			if (er) {
				if (er.code === "EMFILE" && timeout < 1000) {
					return setTimeout(function() {
						_rimraf(p, CB);
					}, timeout++);
				}
				if (er.code === "ENOENT")
					er = null;
			}
			timeout = 0;
			cb(er);
		});
	};
	var rimrafSync = function(p) {
		try {
			try {
				fs.unlinkSync(p);
				return true;
			} catch (er) {
				if (er.code === "ENOENT")
					return true;
				if (er.code === "EPERM")
					return rmdirSync(p, er);
				if (er.code !== "EISDIR")
					throw er;
				return rmdirSync(p, er);
			}
		} catch (failed) {
			return false;
		}
	};
	var _rimraf = function(p, cb) {
		fs.unlink(p, function(er) {
			if (er) {
				if (er.code === "ENOENT")
					return cb(null);
				if (er.code === "EPERM")
					return rmdir(p, er, cb);
				if (er.code === "EISDIR")
					return rmdir(p, er, cb);
			}
			return cb(er);
		});
	};
	var rmdir = function(p, originalEr, cb) {
		fs.rmdir(p, function(er) {
			if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
				rmkids(p, cb);
			else if (er && er.code === "ENOTDIR")
				cb(originalEr);
			else
				cb(er);
		});
	};
	var rmkids = function(p, cb) {
		fs.readdir(p, function(er, files) {
			if (er)
				return cb(er);
			var n = files.length;
			if (n === 0)
				return fs.rmdir(p, cb);
			var errState;
			files.forEach(function(f) {
				rimraf(path.join(p, f), function(er) {
					if (errState)
						return;
					if (er)
						return cb(errState = er);
					if (--n === 0)
						fs.rmdir(p, cb);
				});
			});
		});
	};
	var rmdirSync = function(p, originalEr) {
		try {
			fs.rmdirSync(p);
			return true;
		} catch (er) {
			if (er.code === "ENOENT")
				return true;
			if (er.code === "ENOTDIR")
				throw originalEr;
			if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
				return rmkidsSync(p);
		}
	};
	var rmkidsSync = function(p) {
		fs.readdirSync(p).forEach(function(f) {
			rimrafSync(path.join(p, f));
		});
		fs.rmdirSync(p);
		return true;
	};
	return (_callback ? rimraf(fd, _callback) : rimrafSync(fd));
};

const dir = exports.dir = function(fd, _type, _callback) {
	if (typeof(_type) == "function") {
		_callback = _type;
		_type = null;
	}
	var filter = files => (files || []).filter(x => !_type || x.split(".").pop().toLowerCase() == _type);
	if (_callback) {
		fs.readdir(fd, function(err, f) {
			_callback(err, filter(f));
		});
	} else {
		try {
			return filter(fs.readdirSync(fd));
		} catch (e) {
			return [];
		}
	}
};

const mkdir = exports.mkdir = function(fd, _callback) {
	var dirPath = path.resolve(fd),
		mode = 0x1FF & (~process.umask());
	if (_callback) {
		var mkdirAsync = function(p, next, m) {
			fs.mkdir(p, mode, function(err) {
				if (!err) {
					m = m || p;
					return next(null, m);
				} else if (err.code == "ENOENT") {
					mkdirAsync(path.dirname(p), function(err, m) {
						if (err)
							next(err, m);
						else
							mkdirAsync(p, next, m);
					});
				} else {
					fs.stat(p, function(err2, stat) {
						if (err2 || !stat.isDirectory())
							next(err, m);
						else
							next(null, m);
					});
				}
			});
		};
		mkdirAsync(dirPath, _callback);
	} else {
		var mkdirSync = function(p, m) {
			try {
				fs.mkdirSync(p, mode);
				m = m || p;
			} catch (err) {
				if (err.code == "ENOENT") {
					m = mkdirSync(path.dirname(p), m);
					mkdirSync(p, m);
				} else {
					var stat = null;
					try {
						stat = fs.statSync(p);
					} catch (err2) {
						throw err;
					}
					if (!stat.isDirectory())
						throw err;
				}
			}
			return m;
		};
		mkdirSync(dirPath);
	}
};

const isdir = exports.isdir = function(fd, _callback) {
	if (_callback) {
		fs.stat(fd, function(err, stat) {
			_callback(err, !err && stat && stat.isDirectory() === true);
		});
	} else {
		try {
			return fs.statSync(fd).isDirectory();
		} catch (e) {
			return false;
		}
	}
};

const where = exports.where = function(fn, paths) {
	for (var i = 0; i < paths.length; i++) {
		try {
			var sp = path.resolve(paths[i], fn);
			var stat = fs.statSync(sp);
			if (stat && stat.isFile() === true)
				return sp;
		} catch (e) {

		}
	}
	return null;
};

const walk = exports.walk = function(fd) {
	try {
		var _walk = function(p) {
			var buffer = [];
			dir(p).forEach(function(filename) {
				var fullPath = path.resolve(p, filename);
				if (isdir(fullPath))
					buffer = buffer.concat(_walk(fullPath));
				else
					buffer.push(fullPath);
			});
			return buffer;
		};
		var files = _walk(path.resolve(fd));
		return files;
	} catch (e) {
		return [];
	}
};